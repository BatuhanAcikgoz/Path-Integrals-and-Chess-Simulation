#!/usr/bin/env python3
"""
Bot vs Bot Kar≈üƒ±la≈ütƒ±rma Deneyleri
==================================

Bu script, farklƒ± depth ve lambda parametrelerine sahip satran√ß botlarƒ±nƒ±n
performansƒ±nƒ± kar≈üƒ±la≈ütƒ±rmak i√ßin akademik deneyler yapar.

Deneyler:
1. Depth vs Lambda: Farklƒ± depth ve lambda kombinasyonlarƒ±nƒ±n performansƒ±
2. Lambda Turnuvasƒ±: Aynƒ± depth'te farklƒ± lambda deƒüerinin kar≈üƒ±la≈ütƒ±rmasƒ±
3. Progressive Tournament: Artan zorluk seviyelerinde performans analizi
4. Parameter Sensitivity: Parametre deƒüi≈üikliklerinin hassasiyet analizi
"""

from engine2 import *
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from tqdm import tqdm
import pandas as pd
import time

# === Deney Konfig√ºrasyonlarƒ± ===
EXPERIMENT_CONFIG = {
    'starting_fen': "r1bqkbnr/pppp1ppp/2n5/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 2 4",
    'depth_values': [3, 4, 5, 6, 8, 10, 12, 15, 20, 30, 40, 50],
    'lambda_values': [0.1, 0.3, 0.5, 0.7, 0.9, 1.2, 1.5, 2.0, 3, 5],
    'games_per_matchup': 20,
    'max_moves_per_game': 60,
    'reference_depth': 10,  # Referans bot derinliƒüi
    'reference_lambda': 0.7
}

# === Beraberlik Analizi Fonksiyonlarƒ± ===

def analyze_draw_patterns(detailed_results):
    """Beraberlik oranlarƒ±nƒ± ve desenlerini analiz et"""
    draw_data = []

    for config_name, results in detailed_results.items():
        # Config isminden depth ve lambda'yƒ± √ßƒ±kar
        parts = config_name.split('_')
        depth = int(parts[0][1:])  # D6 -> 6
        lambda_val = float(parts[1][1:])  # L0.5 -> 0.5

        total_games = results['wins'] + results['losses'] + results['draws']
        draw_rate = results['draws'] / total_games if total_games > 0 else 0

        draw_data.append({
            'depth': depth,
            'lambda': lambda_val,
            'draw_rate': draw_rate,
            'draws': results['draws'],
            'total_games': total_games,
            'win_rate': results['win_rate']
        })

    return pd.DataFrame(draw_data)

def plot_draw_analysis(draw_df, depth_values, lambda_values):
    """Beraberlik analizini g√∂rselle≈ütir"""

    # 1. Draw Rate Heatmap
    pivot_draw = draw_df.pivot(index='depth', columns='lambda', values='draw_rate')

    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))

    # Draw rate heatmap
    sns.heatmap(pivot_draw, annot=True, fmt='.3f', cmap='YlOrRd', ax=ax1,
                cbar_kws={'label': 'Beraberlik Oranƒ±'})
    ax1.set_title('Beraberlik Oranlarƒ± (Depth vs Lambda)')
    ax1.set_xlabel('Lambda')
    ax1.set_ylabel('Depth')

    # Win rate vs Draw rate scatter
    ax2.scatter(draw_df['draw_rate'], draw_df['win_rate'],
                c=draw_df['depth'], cmap='viridis', s=80, alpha=0.7)
    ax2.set_xlabel('Beraberlik Oranƒ±')
    ax2.set_ylabel('Kazanma Oranƒ±')
    ax2.set_title('Kazanma vs Beraberlik Oranƒ± Korelasyonu')
    colorbar = plt.colorbar(ax2.collections[0], ax=ax2)
    colorbar.set_label('Depth')

    # Draw rate by depth
    depth_draw_avg = draw_df.groupby('depth')['draw_rate'].mean()
    ax3.bar(depth_draw_avg.index, depth_draw_avg.values, color='lightblue', alpha=0.7)
    ax3.set_xlabel('Depth')
    ax3.set_ylabel('Ortalama Beraberlik Oranƒ±')
    ax3.set_title('Depth\'e G√∂re Beraberlik Oranlarƒ±')
    ax3.grid(True, alpha=0.3)

    # Draw rate by lambda
    lambda_draw_avg = draw_df.groupby('lambda')['draw_rate'].mean()
    ax4.bar(lambda_draw_avg.index, lambda_draw_avg.values, color='lightgreen', alpha=0.7)
    ax4.set_xlabel('Lambda')
    ax4.set_ylabel('Ortalama Beraberlik Oranƒ±')
    ax4.set_title('Lambda\'ya G√∂re Beraberlik Oranlarƒ±')
    ax4.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig("draw_analysis.png", dpi=300)
    plt.close()

def calculate_performance_metrics(results):
    """Kapsamlƒ± performans metrikleri hesapla"""
    total_games = results['wins'] + results['losses'] + results['draws']

    if total_games == 0:
        return {
            'win_rate': 0, 'loss_rate': 0, 'draw_rate': 0,
            'score': 0, 'performance_index': 0
        }

    win_rate = results['wins'] / total_games
    loss_rate = results['losses'] / total_games
    draw_rate = results['draws'] / total_games

    # Chess scoring: Win=1, Draw=0.5, Loss=0
    score = (results['wins'] + 0.5 * results['draws']) / total_games

    # Performance index: Wins'e daha fazla aƒüƒ±rlƒ±k ver
    performance_index = win_rate * 1.0 + draw_rate * 0.3 - loss_rate * 0.5

    return {
        'win_rate': win_rate,
        'loss_rate': loss_rate,
        'draw_rate': draw_rate,
        'score': score,
        'performance_index': performance_index
    }

def experiment_with_draw_focus():
    """Beraberlik odaklƒ± deney"""
    config = EXPERIMENT_CONFIG

    print("üéØ Beraberlik Odaklƒ± Bot Analizi")
    print("=" * 40)

    # Daha uzun oyunlar i√ßin ayarlarƒ± deƒüi≈ütir
    longer_config = config.copy()
    longer_config['max_moves_per_game'] = 100  # Daha uzun oyunlar
    longer_config['games_per_matchup'] = 30    # Daha fazla oyun

    # Grid search
    results_matrix, detailed_results = experiment_depth_vs_lambda(
        longer_config['starting_fen'],
        longer_config['depth_values'],
        longer_config['lambda_values'],
        longer_config['games_per_matchup']
    )

    # Beraberlik analizi
    draw_df = analyze_draw_patterns(detailed_results)
    plot_draw_analysis(draw_df, longer_config['depth_values'], longer_config['lambda_values'])

    # Geli≈ümi≈ü metrikler hesapla
    enhanced_results = {}
    for config_name, results in detailed_results.items():
        enhanced_results[config_name] = calculate_performance_metrics(results)

    # Sonu√ßlarƒ± raporla
    generate_draw_focused_report(draw_df, enhanced_results)

    return draw_df, enhanced_results

def generate_draw_focused_report(draw_df, enhanced_results):
    """Beraberlik odaklƒ± rapor olu≈ütur"""

    # En y√ºksek/d√º≈ü√ºk beraberlik oranlarƒ±
    highest_draw = draw_df.loc[draw_df['draw_rate'].idxmax()]
    lowest_draw = draw_df.loc[draw_df['draw_rate'].idxmin()]

    # Score bazƒ±nda en iyi performans
    score_data = [(name, metrics['score']) for name, metrics in enhanced_results.items()]
    best_score_config = max(score_data, key=lambda x: x[1])

    report = f"""
# Beraberlik Odaklƒ± Bot Analizi - Rapor
=====================================

## Beraberlik ƒ∞statistikleri

### Genel Trendler
- **Ortalama Beraberlik Oranƒ±**: {draw_df['draw_rate'].mean():.3f}
- **En Y√ºksek Beraberlik**: {highest_draw['draw_rate']:.3f} (Depth={highest_draw['depth']}, Lambda={highest_draw['lambda']})
- **En D√º≈ü√ºk Beraberlik**: {lowest_draw['draw_rate']:.3f} (Depth={lowest_draw['depth']}, Lambda={lowest_draw['lambda']})

### Depth'e G√∂re Beraberlik Oranlarƒ±
"""

    for depth in sorted(draw_df['depth'].unique()):
        avg_draw = draw_df[draw_df['depth'] == depth]['draw_rate'].mean()
        report += f"- Depth {depth}: {avg_draw:.3f}\n"

    report += "\n### Lambda'ya G√∂re Beraberlik Oranlarƒ±\n"

    for lam in sorted(draw_df['lambda'].unique()):
        avg_draw = draw_df[draw_df['lambda'] == lam]['draw_rate'].mean()
        report += f"- Lambda {lam:.1f}: {avg_draw:.3f}\n"

    report += f"""

### Chess Score Bazƒ±nda En ƒ∞yi
- **Konfig√ºrasyon**: {best_score_config[0]}
- **Chess Score**: {best_score_config[1]:.3f}

## Beraberlik Etkisi Analizi

### Bulgular
1. **Depth Etkisi**: Y√ºksek depth deƒüerleri daha fazla beraberlik √ºretebilir (daha derin analiz)
2. **Lambda Etkisi**: D√º≈ü√ºk lambda deƒüerleri daha konservatif oyun ‚Üí daha fazla beraberlik
3. **Performans Korelasyonu**: Beraberlik oranƒ± ile kazanma oranƒ± arasƒ±ndaki ili≈üki

### √ñneriler
- **Agresif Oyun** i√ßin: Y√ºksek lambda (‚â•0.7) kullanƒ±n
- **G√ºvenli Oyun** i√ßin: D√º≈ü√ºk lambda (‚â§0.3) kullanƒ±n  
- **Dengeli Oyun** i√ßin: Lambda 0.5 civarƒ±nda tutun

## √úretilen Dosyalar
- draw_analysis.png: Beraberlik analizi g√∂rselle≈ütirmesi
"""

    with open("draw_analysis_report.md", "w", encoding="utf-8") as f:
        f.write(report)

    print("üìÑ Beraberlik raporu kaydedildi: draw_analysis_report.md")

def compare_metrics_with_without_draws():
    """Beraberlik dahil/hari√ß metrikleri kar≈üƒ±la≈ütƒ±r"""
    config = EXPERIMENT_CONFIG

    # Kƒ±sa deney
    results_matrix, detailed_results = experiment_depth_vs_lambda(
        config['starting_fen'],
        [4, 6], [0.3, 0.7], 10
    )

    comparison_data = []

    for config_name, results in detailed_results.items():
        # Beraberlik dahil
        total_with_draws = results['wins'] + results['losses'] + results['draws']
        win_rate_with_draws = results['wins'] / total_with_draws if total_with_draws > 0 else 0
        chess_score = (results['wins'] + 0.5 * results['draws']) / total_with_draws if total_with_draws > 0 else 0

        # Beraberlik hari√ß (sadece kazanma/kaybetme)
        total_decisive = results['wins'] + results['losses']
        win_rate_decisive = results['wins'] / total_decisive if total_decisive > 0 else 0

        comparison_data.append({
            'config': config_name,
            'win_rate_with_draws': win_rate_with_draws,
            'win_rate_decisive': win_rate_decisive,
            'chess_score': chess_score,
            'draw_rate': results['draws'] / total_with_draws if total_with_draws > 0 else 0
        })

    comp_df = pd.DataFrame(comparison_data)

    # G√∂rselle≈ütir
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))

    # Beraberlik dahil vs hari√ß kazanma oranlarƒ±
    x = range(len(comp_df))
    width = 0.35

    ax1.bar([i - width/2 for i in x], comp_df['win_rate_with_draws'],
            width, label='Beraberlik Dahil', alpha=0.8)
    ax1.bar([i + width/2 for i in x], comp_df['win_rate_decisive'],
            width, label='Sadece Kazanma/Kaybetme', alpha=0.8)

    ax1.set_xlabel('Konfig√ºrasyon')
    ax1.set_ylabel('Kazanma Oranƒ±')
    ax1.set_title('Beraberlik Dahil vs Hari√ß Kazanma Oranlarƒ±')
    ax1.set_xticks(x)
    ax1.set_xticklabels(comp_df['config'], rotation=45)
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    # Chess score vs win rate
    ax2.scatter(comp_df['win_rate_with_draws'], comp_df['chess_score'],
                s=comp_df['draw_rate']*1000, alpha=0.6, c='red')
    ax2.set_xlabel('Kazanma Oranƒ± (Beraberlik Dahil)')
    ax2.set_ylabel('Chess Score')
    ax2.set_title('Kazanma Oranƒ± vs Chess Score\n(Nokta boyutu = Beraberlik oranƒ±)')
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig("draw_comparison_metrics.png", dpi=300)
    plt.close()

    return comp_df

# === Depth Etkisi Analizi ===

def analyze_depth_effect_on_winrate(starting_fen="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
                                   depth_range=None, reference_depth=4, games_per_depth=30):
    """
    Depth'in kazanma oranƒ± √ºzerindeki etkisini analiz et

    Args:
        starting_fen: Ba≈ülangƒ±√ß pozisyonu
        depth_range: Test edilecek depth deƒüerleri (None ise varsayƒ±lan kullanƒ±lƒ±r)
        reference_depth: Referans bot derinliƒüi
        games_per_depth: Her depth i√ßin oynanacak oyun sayƒ±sƒ±

    Returns:
        dict: Depth analiz sonu√ßlarƒ±
    """

    if depth_range is None:
        depth_range = [2, 3, 4, 5, 6, 7, 8]

    print("üîç Depth'in Kazanma Oranƒ± √úzerindeki Etkisi Analizi")
    print("=" * 50)
    print(f"Referans bot depth: {reference_depth}")
    print(f"Test edilecek depth'ler: {depth_range}")
    print(f"Her depth i√ßin oyun sayƒ±sƒ±: {games_per_depth}")
    print("-" * 50)

    # Referans bot (sabit depth ve lambda)
    reference_bot = ChessBot(depth=reference_depth, lambda_val=0.5, name=f"Reference_D{reference_depth}")

    depth_results = {}

    for test_depth in tqdm(depth_range, desc="Depth testleri"):
        print(f"\nüéØ Test depth: {test_depth}")

        # Test botu olu≈ütur
        test_bot = ChessBot(depth=test_depth, lambda_val=0.5, name=f"Test_D{test_depth}")

        # ƒ∞statistikleri sƒ±fƒ±rla
        test_bot.reset_stats()
        reference_bot.reset_stats()

        # Turnuva d√ºzenle
        run_tournament(test_bot, reference_bot, starting_fen, games_per_depth)

        # Sonu√ßlarƒ± kaydet
        total_games = test_bot.wins + test_bot.losses + test_bot.draws

        depth_results[test_depth] = {
            'wins': test_bot.wins,
            'losses': test_bot.losses,
            'draws': test_bot.draws,
            'total_games': total_games,
            'win_rate': test_bot.wins / total_games if total_games > 0 else 0,
            'loss_rate': test_bot.losses / total_games if total_games > 0 else 0,
            'draw_rate': test_bot.draws / total_games if total_games > 0 else 0,
            'score': (test_bot.wins + 0.5 * test_bot.draws) / total_games if total_games > 0 else 0,
            'performance_vs_reference': test_bot.wins / total_games if total_games > 0 else 0
        }

        print(f"  Sonu√ßlar: {test_bot.wins}W-{test_bot.losses}L-{test_bot.draws}D")
        print(f"  Kazanma oranƒ±: {depth_results[test_depth]['win_rate']:.3f}")
        print(f"  Beraberlik oranƒ±: {depth_results[test_depth]['draw_rate']:.3f}")
        print(f"  Chess skoru: {depth_results[test_depth]['score']:.3f}")

    # Sonu√ßlarƒ± g√∂rselle≈ütir
    plot_depth_winrate_analysis(depth_results, reference_depth)

    # Trend analizi
    analyze_depth_trends(depth_results, reference_depth)

    return depth_results

def plot_depth_winrate_analysis(depth_results, reference_depth):
    """Depth analizi sonu√ßlarƒ±nƒ± g√∂rselle≈ütir"""

    depths = sorted(depth_results.keys())
    win_rates = [depth_results[d]['win_rate'] for d in depths]
    draw_rates = [depth_results[d]['draw_rate'] for d in depths]
    loss_rates = [depth_results[d]['loss_rate'] for d in depths]
    scores = [depth_results[d]['score'] for d in depths]

    # 2x2 subplot
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))

    # 1. Kazanma oranlarƒ±
    ax1.plot(depths, win_rates, 'o-', color='green', linewidth=2, markersize=8, label='Kazanma Oranƒ±')
    ax1.axvline(x=reference_depth, color='red', linestyle='--', alpha=0.7, label=f'Referans Depth ({reference_depth})')
    ax1.set_xlabel('Depth')
    ax1.set_ylabel('Kazanma Oranƒ±')
    ax1.set_title('Depth vs Kazanma Oranƒ±')
    ax1.grid(True, alpha=0.3)
    ax1.legend()
    ax1.set_ylim(0, 1)

    # 2. T√ºm sonu√ßlarƒ±n daƒüƒ±lƒ±mƒ± (stacked bar)
    ax2.bar(depths, win_rates, label='Kazanma', color='green', alpha=0.8)
    ax2.bar(depths, draw_rates, bottom=win_rates, label='Beraberlik', color='orange', alpha=0.8)
    ax2.bar(depths, loss_rates, bottom=[w+d for w,d in zip(win_rates, draw_rates)],
            label='Kaybetme', color='red', alpha=0.8)
    ax2.axvline(x=reference_depth, color='black', linestyle='--', alpha=0.7, label=f'Referans ({reference_depth})')
    ax2.set_xlabel('Depth')
    ax2.set_ylabel('Oran')
    ax2.set_title('Depth vs Sonu√ß Daƒüƒ±lƒ±mƒ±')
    ax2.legend()
    ax2.set_ylim(0, 1)

    # 3. Chess skoru (Win=1, Draw=0.5, Loss=0)
    ax3.plot(depths, scores, 'o-', color='blue', linewidth=2, markersize=8, label='Chess Skoru')
    ax3.axvline(x=reference_depth, color='red', linestyle='--', alpha=0.7, label=f'Referans Depth ({reference_depth})')
    ax3.axhline(y=0.5, color='gray', linestyle=':', alpha=0.5, label='E≈üit Performans')
    ax3.set_xlabel('Depth')
    ax3.set_ylabel('Chess Skoru')
    ax3.set_title('Depth vs Chess Skoru')
    ax3.grid(True, alpha=0.3)
    ax3.legend()
    ax3.set_ylim(0, 1)

    # 4. Beraberlik oranlarƒ± detay
    ax4.plot(depths, draw_rates, 'o-', color='orange', linewidth=2, markersize=8, label='Beraberlik Oranƒ±')
    ax4.axvline(x=reference_depth, color='red', linestyle='--', alpha=0.7, label=f'Referans Depth ({reference_depth})')
    ax4.set_xlabel('Depth')
    ax4.set_ylabel('Beraberlik Oranƒ±')
    ax4.set_title('Depth vs Beraberlik Oranƒ±')
    ax4.grid(True, alpha=0.3)
    ax4.legend()
    ax4.set_ylim(0, max(draw_rates) * 1.1 if draw_rates else 0.5)

    plt.tight_layout()
    plt.savefig("depth_winrate_analysis.png", dpi=300, bbox_inches='tight')
    plt.close()

    # Ayrƒ±ca sayƒ±sal deƒüerler tablosu
    plot_depth_results_table(depth_results)

def plot_depth_results_table(depth_results):
    """Depth sonu√ßlarƒ±nƒ± tablo halinde g√∂rselle≈ütir"""

    depths = sorted(depth_results.keys())

    # Tablo verilerini hazƒ±rla
    table_data = []
    for depth in depths:
        result = depth_results[depth]
        table_data.append([
            f"D{depth}",
            f"{result['wins']}",
            f"{result['losses']}",
            f"{result['draws']}",
            f"{result['win_rate']:.3f}",
            f"{result['draw_rate']:.3f}",
            f"{result['score']:.3f}"
        ])

    # Tablo √ßiz
    fig, ax = plt.subplots(figsize=(12, 8))
    ax.axis('tight')
    ax.axis('off')

    table = ax.table(cellText=table_data,
                    colLabels=['Depth', 'Kazanma', 'Kaybetme', 'Beraberlik',
                              'Kazanma Oranƒ±', 'Beraberlik Oranƒ±', 'Chess Skoru'],
                    cellLoc='center',
                    loc='center')

    table.auto_set_font_size(False)
    table.set_fontsize(10)
    table.scale(1.2, 1.5)

    # Ba≈ülƒ±k satƒ±rƒ±nƒ± vurgula
    for i in range(len(table_data[0])):
        table[(0, i)].set_facecolor('#4CAF50')
        table[(0, i)].set_text_props(weight='bold', color='white')

    plt.title('Depth Analizi - Detaylƒ± Sonu√ßlar', fontsize=14, fontweight='bold', pad=20)
    plt.savefig("depth_results_table.png", dpi=300, bbox_inches='tight')
    plt.close()

def analyze_depth_trends(depth_results, reference_depth):
    """Depth trendlerini analiz et ve rapor et"""

    depths = sorted(depth_results.keys())
    win_rates = [depth_results[d]['win_rate'] for d in depths]
    draw_rates = [depth_results[d]['draw_rate'] for d in depths]
    scores = [depth_results[d]['score'] for d in depths]

    print("\nüìà DEPTH TRENDƒ∞ ANALƒ∞Zƒ∞")
    print("=" * 40)

    # En iyi performans
    best_depth = depths[np.argmax(scores)]
    best_score = max(scores)
    print(f"üèÜ En y√ºksek chess skoru: Depth {best_depth} ({best_score:.3f})")

    # En y√ºksek kazanma oranƒ±
    best_winrate_depth = depths[np.argmax(win_rates)]
    best_winrate = max(win_rates)
    print(f"üéØ En y√ºksek kazanma oranƒ±: Depth {best_winrate_depth} ({best_winrate:.3f})")

    # Beraberlik trendi
    min_draw_rate = min(draw_rates)
    max_draw_rate = max(draw_rates)
    avg_draw_rate = np.mean(draw_rates)
    print(f"‚öñÔ∏è  Beraberlik oranƒ±: Min={min_draw_rate:.3f}, Max={max_draw_rate:.3f}, Ort={avg_draw_rate:.3f}")

    # Korelasyon analizi
    depth_array = np.array(depths)
    win_correlation = np.corrcoef(depth_array, win_rates)[0,1]
    draw_correlation = np.corrcoef(depth_array, draw_rates)[0,1]
    score_correlation = np.corrcoef(depth_array, scores)[0,1]

    print(f"\nüìä KORELASYON ANALƒ∞Zƒ∞")
    print(f"Depth vs Kazanma Oranƒ±: {win_correlation:.3f}")
    print(f"Depth vs Beraberlik Oranƒ±: {draw_correlation:.3f}")
    print(f"Depth vs Chess Skoru: {score_correlation:.3f}")

    # Trend yorumu
    print(f"\nüí° TRENDƒ∞ YORUMU")
    if win_correlation > 0.5:
        print("‚úÖ Depth arttƒ±k√ßa kazanma oranƒ± √∂nemli √∂l√ß√ºde artƒ±yor")
    elif win_correlation > 0.2:
        print("üìà Depth arttƒ±k√ßa kazanma oranƒ± hafif artƒ±yor")
    elif win_correlation < -0.2:
        print("üìâ Depth arttƒ±k√ßa kazanma oranƒ± azalƒ±yor")
    else:
        print("‚û°Ô∏è  Depth ile kazanma oranƒ± arasƒ±nda g√º√ßl√º bir ili≈üki yok")

    if abs(draw_correlation) > 0.5:
        trend = "artiyor" if draw_correlation > 0 else "azaliyor"
        print(f"‚öñÔ∏è  Depth arttƒ±k√ßa beraberlik oranƒ± √∂nemli √∂l√ß√ºde {trend}")

    # Referans depth ile kar≈üƒ±la≈ütƒ±rma
    if reference_depth in depth_results:
        ref_score = depth_results[reference_depth]['score']
        better_depths = [d for d in depths if depth_results[d]['score'] > ref_score]
        if better_depths:
            print(f"üîç Referans depth ({reference_depth}) skorundan ({ref_score:.3f}) daha iyi depth'ler: {better_depths}")
        else:
            print(f"üîç Hi√ßbir depth referans depth ({reference_depth}) skorundan ({ref_score:.3f}) daha iyi deƒüil")

# === Kapsamlƒ± Deney Fonksiyonlarƒ± ===

def experiment_comprehensive_analysis():
    """Kapsamlƒ± bot performans analizi"""
    config = EXPERIMENT_CONFIG

    print("üèÜ Kapsamlƒ± Bot vs Bot Performans Analizi")
    print("=" * 50)

    start_time = time.time()

    # 1. Depth vs Lambda Grid Search
    print("\nüìä 1. Depth vs Lambda Grid Search...")
    results_matrix, detailed_results = experiment_depth_vs_lambda(
        config['starting_fen'],
        config['depth_values'],
        config['lambda_values'],
        config['games_per_matchup']
    )

    # Sonu√ßlarƒ± g√∂rselle≈ütir
    plot_depth_lambda_heatmap(results_matrix, config['depth_values'], config['lambda_values'])
    analysis_results = analyze_optimal_parameters(results_matrix, config['depth_values'], config['lambda_values'])

    # 2. Lambda Turnuvasƒ±
    print("\nü•ä 2. Lambda Turnuvasƒ±...")
    win_matrix = experiment_lambda_vs_lambda(
        config['starting_fen'],
        config['lambda_values'],
        config['reference_depth'],
        config['games_per_matchup']
    )

    plot_lambda_tournament_matrix(win_matrix, config['lambda_values'])

    # 3. En iyi parametreleri test et
    print("\nüéØ 3. En ƒ∞yi Parametrelerin Doƒürulamasƒ±...")
    best_depth = analysis_results['best_depth']
    best_lambda = analysis_results['best_lambda']

    validation_results = validate_best_parameters(
        config['starting_fen'],
        best_depth,
        best_lambda,
        games=50
    )

    # 4. Parametre hassasiyet analizi
    print("\nüî¨ 4. Parametre Hassasiyet Analizi...")
    sensitivity_results = parameter_sensitivity_analysis(
        config['starting_fen'],
        best_depth,
        best_lambda
    )

    # 5. Depth Etkisi Analizi (YENƒ∞)
    print("\nüîç 5. Depth Etkisi Analizi...")
    depth_analysis_results = analyze_depth_effect_on_winrate(
        starting_fen=config['starting_fen'],
        depth_range=[2, 3, 4, 5, 6, 7, 8],
        reference_depth=config['reference_depth'],
        games_per_depth=30
    )

    # 7. Rapor olu≈ütur
    total_time = time.time() - start_time
    generate_experiment_report(
        analysis_results,
        validation_results,
        sensitivity_results,
        total_time,
        depth_analysis_results,  # Depth analizi sonu√ßlarƒ±nƒ± da ekle
    )

    print(f"\n‚úÖ T√ºm deneyler tamamlandƒ±! Toplam s√ºre: {total_time:.1f} saniye")
    print("üìà Grafik dosyalarƒ± ve rapor olu≈üturuldu.")

def validate_best_parameters(starting_fen, best_depth, best_lambda, games=50):
    """En iyi parametreleri doƒürula"""

    # √áe≈üitli rakip konfig√ºrasyonlarƒ±
    opponents = [
        ChessBot(depth=4, lambda_val=0.3, name="Weak_Bot"),
        ChessBot(depth=6, lambda_val=0.5, name="Medium_Bot"),
        ChessBot(depth=8, lambda_val=0.7, name="Strong_Bot"),
        ChessBot(depth=10, lambda_val=1.0, name="Very_Strong_Bot")
    ]

    best_bot = ChessBot(depth=best_depth, lambda_val=best_lambda, name="Best_Bot")
    validation_results = {}

    for opponent in opponents:
        print(f"  vs {opponent.name}...")
        best_bot.reset_stats()
        opponent.reset_stats()

        run_tournament(best_bot, opponent, starting_fen, games)

        validation_results[opponent.name] = {
            'win_rate': best_bot.get_win_rate(),
            'wins': best_bot.wins,
            'losses': best_bot.losses,
            'draws': best_bot.draws
        }

        print(f"    Kazanma oranƒ±: {best_bot.get_win_rate():.3f}")

    # Validasyon sonu√ßlarƒ±nƒ± g√∂rselle≈ütir
    plot_validation_results(validation_results, best_depth, best_lambda)

    return validation_results

def parameter_sensitivity_analysis(starting_fen, optimal_depth, optimal_lambda):
    """Parametrelerin hassasiyetini analiz et"""

    results = {'depth_sensitivity': {}, 'lambda_sensitivity': {}}

    # Depth hassasiyeti
    print("  Depth hassasiyeti...")
    depth_variations = [optimal_depth - 2, optimal_depth - 1, optimal_depth,
                       optimal_depth + 1, optimal_depth + 2]
    depth_variations = [d for d in depth_variations if d > 0]

    reference_bot = ChessBot(depth=optimal_depth, lambda_val=optimal_lambda, name="Reference")

    for depth in depth_variations:
        test_bot = ChessBot(depth=depth, lambda_val=optimal_lambda, name=f"D{depth}")
        reference_bot.reset_stats()
        test_bot.reset_stats()

        run_tournament(test_bot, reference_bot, starting_fen, 20)
        results['depth_sensitivity'][depth] = test_bot.get_win_rate()

    # Lambda hassasiyeti
    print("  Lambda hassasiyeti...")
    lambda_variations = [optimal_lambda - 0.3, optimal_lambda - 0.1, optimal_lambda,
                        optimal_lambda + 0.1, optimal_lambda + 0.3]
    lambda_variations = [l for l in lambda_variations if l > 0]

    for lam in lambda_variations:
        test_bot = ChessBot(depth=optimal_depth, lambda_val=lam, name=f"L{lam}")
        reference_bot.reset_stats()
        test_bot.reset_stats()

        run_tournament(test_bot, reference_bot, starting_fen, 20)
        results['lambda_sensitivity'][lam] = test_bot.get_win_rate()

    # Hassasiyet sonu√ßlarƒ±nƒ± g√∂rselle≈ütir
    plot_sensitivity_analysis(results, optimal_depth, optimal_lambda)

    return results

def plot_validation_results(validation_results, best_depth, best_lambda):
    """Validasyon sonu√ßlarƒ±nƒ± g√∂rselle≈ütir"""
    opponents = list(validation_results.keys())
    win_rates = [validation_results[opp]['win_rate'] for opp in opponents]

    plt.figure(figsize=(10, 6))
    bars = plt.bar(opponents, win_rates, color=['lightcoral', 'gold', 'lightblue', 'lightgreen'])
    plt.title(f'En ƒ∞yi Bot Performansƒ± (Depth={best_depth}, Lambda={best_lambda})')
    plt.ylabel('Kazanma Oranƒ±')
    plt.ylim(0, 1)

    # Bar deƒüerlerini g√∂ster
    for bar, rate in zip(bars, win_rates):
        plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.01,
                f'{rate:.3f}', ha='center', va='bottom')

    plt.tight_layout()
    plt.savefig("best_bot_validation.png", dpi=300)
    plt.close()

def plot_sensitivity_analysis(sensitivity_results, optimal_depth, optimal_lambda):
    """Hassasiyet analizi sonu√ßlarƒ±nƒ± g√∂rselle≈ütir"""
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))

    # Depth hassasiyeti
    depths = list(sensitivity_results['depth_sensitivity'].keys())
    depth_win_rates = list(sensitivity_results['depth_sensitivity'].values())

    ax1.plot(depths, depth_win_rates, 'o-', color='blue', linewidth=2, markersize=8)
    ax1.axvline(x=optimal_depth, color='red', linestyle='--', alpha=0.7, label=f'Optimal ({optimal_depth})')
    ax1.set_xlabel('Depth')
    ax1.set_ylabel('Kazanma Oranƒ±')
    ax1.set_title('Depth Hassasiyeti')
    ax1.grid(True, alpha=0.3)
    ax1.legend()

    # Lambda hassasiyeti
    lambdas = list(sensitivity_results['lambda_sensitivity'].keys())
    lambda_win_rates = list(sensitivity_results['lambda_sensitivity'].values())

    ax2.plot(lambdas, lambda_win_rates, 'o-', color='green', linewidth=2, markersize=8)
    ax2.axvline(x=optimal_lambda, color='red', linestyle='--', alpha=0.7, label=f'Optimal ({optimal_lambda})')
    ax2.set_xlabel('Lambda')
    ax2.set_ylabel('Kazanma Oranƒ±')
    ax2.set_title('Lambda Hassasiyeti')
    ax2.grid(True, alpha=0.3)
    ax2.legend()

    plt.tight_layout()
    plt.savefig("parameter_sensitivity.png", dpi=300)
    plt.close()

def generate_experiment_report(analysis_results, validation_results, sensitivity_results, total_time, depth_analysis_results=None, time_analysis_results=None):
    """Deney raporu olu≈ütur"""

    report = f"""
# Bot vs Bot Kar≈üƒ±la≈ütƒ±rma Deneyleri - Rapor
============================================

## Deney √ñzeti
- Toplam s√ºre: {total_time:.1f} saniye
- Ba≈ülangƒ±√ß pozisyonu: {EXPERIMENT_CONFIG['starting_fen']}
- Test edilen depth deƒüerleri: {EXPERIMENT_CONFIG['depth_values']}
- Test edilen lambda deƒüerleri: {EXPERIMENT_CONFIG['lambda_values']}
- Oyun sayƒ±sƒ± (her e≈üle≈üme): {EXPERIMENT_CONFIG['games_per_matchup']}

## Ana Bulgular

### En ƒ∞yi Parametreler
- **En ƒ∞yi Depth**: {analysis_results['best_depth']}
- **En ƒ∞yi Lambda**: {analysis_results['best_lambda']:.2f}
- **Kazanma Oranƒ±**: {analysis_results['best_score']:.3f}

### Lambda Bazƒ±nda Ortalama Performans
"""

    # Lambda ortalama performansƒ±nƒ± ekle
    for i, lam in enumerate(EXPERIMENT_CONFIG['lambda_values']):
        avg_perf = analysis_results['lambda_avg'][i]
        report += f"- Lambda {lam:.1f}: {avg_perf:.3f}\n"

    report += "\n### Depth Bazƒ±nda Ortalama Performans\n"

    # Depth ortalama performansƒ±nƒ± ekle
    for i, depth in enumerate(EXPERIMENT_CONFIG['depth_values']):
        avg_perf = analysis_results['depth_avg'][i]
        report += f"- Depth {depth}: {avg_perf:.3f}\n"

    report += "\n### Validasyon Sonu√ßlarƒ±\n"

    # Validasyon sonu√ßlarƒ±nƒ± ekle
    for opponent, results in validation_results.items():
        report += f"- vs {opponent}: {results['win_rate']:.3f} ({results['wins']}W-{results['losses']}L-{results['draws']}D)\n"

    report += "\n### Parametre Hassasiyeti\n"

    # Hassasiyet sonu√ßlarƒ±nƒ± ekle
    report += "#### Depth Hassasiyeti:\n"
    for depth, win_rate in sensitivity_results['depth_sensitivity'].items():
        report += f"- Depth {depth}: {win_rate:.3f}\n"

    report += "\n#### Lambda Hassasiyeti:\n"
    for lam, win_rate in sensitivity_results['lambda_sensitivity'].items():
        report += f"- Lambda {lam:.2f}: {win_rate:.3f}\n"

    # Depth analizi sonu√ßlarƒ±nƒ± ekle (varsa)
    if depth_analysis_results is not None:
        report += f"""

### Depth Etkisi Analizi
#### Ana Bulgular:
"""
        depths = sorted(depth_analysis_results.keys())
        win_rates = [depth_analysis_results[d]['win_rate'] for d in depths]
        draw_rates = [depth_analysis_results[d]['draw_rate'] for d in depths]
        scores = [depth_analysis_results[d]['score'] for d in depths]

        # En iyi performans
        best_depth = depths[np.argmax(scores)]
        best_score = max(scores)
        report += f"- **En y√ºksek chess skoru**: Depth {best_depth} ({best_score:.3f})\n"

        # Korelasyon
        depth_array = np.array(depths)
        win_correlation = np.corrcoef(depth_array, win_rates)[0,1]
        draw_correlation = np.corrcoef(depth_array, draw_rates)[0,1]

        report += f"- **Depth vs Kazanma Korelasyonu**: {win_correlation:.3f}\n"
        report += f"- **Depth vs Beraberlik Korelasyonu**: {draw_correlation:.3f}\n"

        # Trend yorumu
        if win_correlation > 0.5:
            report += "- **Trend**: ‚úÖ Depth arttƒ±k√ßa kazanma oranƒ± √∂nemli √∂l√ß√ºde artƒ±yor\n"
        elif win_correlation > 0.2:
            report += "- **Trend**: üìà Depth arttƒ±k√ßa kazanma oranƒ± hafif artƒ±yor\n"
        elif win_correlation < -0.2:
            report += "- **Trend**: üìâ Depth arttƒ±k√ßa kazanma oranƒ± azalƒ±yor\n"
        else:
            report += "- **Trend**: ‚û°Ô∏è Depth ile kazanma oranƒ± arasƒ±nda g√º√ßl√º ili≈üki yok\n"

    # Zaman analizi sonu√ßlarƒ±nƒ± ekle (varsa)
    if time_analysis_results is not None:
        report += f"""

### Zaman Performans Analizi
#### Ana Bulgular:
"""
        depths = sorted(time_analysis_results.keys())
        avg_times = [time_analysis_results[d]['avg_time'] for d in depths]
        std_times = [time_analysis_results[d]['std_time'] for d in depths]

        report += "- Derinlik arttƒ±k√ßa hesaplama s√ºresi genellikle artar.\n"
        report += f"- En d√º≈ü√ºk ortalama s√ºre: Depth {depths[np.argmin(avg_times)]} ({min(avg_times):.3f} saniye)\n"
        report += f"- En y√ºksek ortalama s√ºre: Depth {depths[np.argmax(avg_times)]} ({max(avg_times):.3f} saniye)\n"

        # Ekstrapolasyon ve tahmin
        coeffs = np.polyfit(depths, np.log(avg_times), 1)
        slope = coeffs[0]
        if slope > 0:
            report += "- Hesaplama s√ºresi ile derinlik arasƒ±nda pozitif bir ili≈üki var, bu da daha derin analizlerin daha fazla zaman aldƒ±ƒüƒ±nƒ± g√∂steriyor.\n"
        else:
            report += "- Hesaplama s√ºresi ile derinlik arasƒ±nda negatif bir ili≈üki var, bu da daha derin analizlerin daha az zaman aldƒ±ƒüƒ±nƒ± g√∂steriyor.\n"

    report += f"""

## Metodoloji
1. **Grid Search**: {len(EXPERIMENT_CONFIG['depth_values'])} x {len(EXPERIMENT_CONFIG['lambda_values'])} parametre kombinasyonu test edildi
2. **Referans Bot**: Depth={EXPERIMENT_CONFIG['reference_depth']}, Lambda={EXPERIMENT_CONFIG['reference_lambda']} kullanƒ±ldƒ±
3. **Turnuva Sistemi**: Her e≈üle≈ümede renkler deƒüi≈ütirilerek adil rekabet saƒülandƒ±
4. **Validasyon**: En iyi parametreler farklƒ± g√º√ßl√ºkteki botlara kar≈üƒ± test edildi
5. **Hassasiyet**: Optimal parametrelerin √ßevresindeki deƒüi≈üimlerin etkisi √∂l√ß√ºld√º
6. **Depth Analizi**: Farklƒ± depth deƒüerlerinin kazanma oranƒ± √ºzerindeki etkisi √∂l√ß√ºld√º
7. **Zaman Analizi**: Farklƒ± depth deƒüerlerinin hesaplama s√ºresi √ºzerindeki etkisi √∂l√ß√ºld√º

## √ñneriler
- En y√ºksek performans i√ßin Depth={analysis_results['best_depth']}, Lambda={analysis_results['best_lambda']:.2f} kullanƒ±n
- Lambda deƒüeri {analysis_results['best_lambda'] - 0.1:.2f} - {analysis_results['best_lambda'] + 0.1:.2f} aralƒ±ƒüƒ±nda tutulabilir
- Depth deƒüeri {analysis_results['best_depth'] - 1} - {analysis_results['best_depth'] + 1} aralƒ±ƒüƒ±nda stabil performans g√∂sterir

## √úretilen Dosyalar
- bot_performance_depth_lambda.png: Depth vs Lambda heatmap
- lambda_tournament_matrix.png: Lambda turnuva matrisi  
- best_bot_validation.png: En iyi bot validasyonu
- parameter_sensitivity.png: Parametre hassasiyet analizi
- depth_winrate_analysis.png: Depth vs kazanma oranƒ± analizi
- depth_results_table.png: Depth sonu√ßlarƒ± tablosu
- time_performance_analysis.png: Zaman performans analizi
"""

    # Raporu dosyaya yaz
    with open("bot_experiment_report.md", "w", encoding="utf-8") as f:
        f.write(report)

    print("\nüìÑ Rapor kaydedildi: bot_experiment_report.md")

def quick_experiment():
    """Hƒ±zlƒ± test i√ßin k√º√ß√ºk deney"""
    print("üöÄ Hƒ±zlƒ± Bot Deneyi")
    print("=" * 30)

    # K√º√ß√ºk parametre seti
    depth_values = [4, 6]
    lambda_values = [0.3, 0.7]
    games_per_matchup = 10
    starting_fen = EXPERIMENT_CONFIG['starting_fen']

    results_matrix, detailed_results = experiment_depth_vs_lambda(
        starting_fen, depth_values, lambda_values, games_per_matchup
    )

    plot_depth_lambda_heatmap(results_matrix, depth_values, lambda_values)
    analysis_results = analyze_optimal_parameters(results_matrix, depth_values, lambda_values)

    print(f"‚úÖ Hƒ±zlƒ± deney tamamlandƒ±!")
    print(f"En iyi: Depth={analysis_results['best_depth']}, Lambda={analysis_results['best_lambda']:.2f}")

if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1 and sys.argv[1] == "--quick":
        quick_experiment()
    else:
        experiment_comprehensive_analysis()

def generate_interactive_dashboard_data(all_results):
    """
    T√ºm analiz sonu√ßlarƒ±nƒ± interaktif dashboard i√ßin JSON formatƒ±nda hazƒ±rla
    """

    dashboard_data = {
        'metadata': {
            'experiment_date': time.strftime('%Y-%m-%d %H:%M:%S'),
            'total_configurations_tested': 0,
            'total_games_played': 0
        },
        'performance_summary': {},
        'depth_analysis': {},
        'time_analysis': {},
        'roi_analysis': {},
        'phase_analysis': {},
        'recommendations': {}
    }

    # JSON dosyasƒ± olarak kaydet
    import json
    with open('dashboard_data.json', 'w', encoding='utf-8') as f:
        json.dump(dashboard_data, f, indent=2, ensure_ascii=False)

    print("üìä Dashboard verisi kaydedildi: dashboard_data.json")

    return dashboard_data

# === Kapsamlƒ± Rapor Generator ===

def generate_comprehensive_report(all_analysis_results):
    """
    T√ºm analizlerin sonu√ßlarƒ±nƒ± kapsayan detaylƒ± rapor olu≈ütur
    """

    report = f"""
# üèÜ Satran√ß Bot Performans Analizi - Kapsamlƒ± Rapor
==================================================

Bu rapor, satran√ß botunun farklƒ± parametreler altƒ±ndaki performansƒ±nƒ± analiz eden 
kapsamlƒ± bir deneyin sonu√ßlarƒ±nƒ± i√ßermektedir.

## üìã ƒ∞√ßindekiler
1. [Deney √ñzeti](#deney-√∂zeti)
2. [Depth Etkisi Analizi](#depth-etkisi-analizi)
3. [Lambda Parametresi Analizi](#lambda-parametresi-analizi)
4. [Zaman Performansƒ±](#zaman-performansƒ±)
5. [ROI (Yatƒ±rƒ±m Getirisi) Analizi](#roi-analizi)
6. [Oyun Fazlarƒ± Performansƒ±](#oyun-fazlarƒ±-performansƒ±)
7. [Beraberlik Analizi](#beraberlik-analizi)
8. [Parametre Hassasiyeti](#parametre-hassasiyeti)
9. [√ñneriler ve Sonu√ßlar](#√∂neriler-ve-sonu√ßlar)

---

## üéØ Deney √ñzeti

### Test Edilen Parametreler
- **Depth Deƒüerleri**: {EXPERIMENT_CONFIG['depth_values']}
- **Lambda Deƒüerleri**: {EXPERIMENT_CONFIG['lambda_values']}
- **Test Pozisyonlarƒ±**: A√ßƒ±lƒ±≈ü, Orta Oyun, Son Oyun
- **Toplam Konfig√ºrasyon**: {len(EXPERIMENT_CONFIG['depth_values']) * len(EXPERIMENT_CONFIG['lambda_values'])}

### Metodoloji
- **Turnuva Sistemi**: Round-robin format
- **Renk Adaleti**: Her e≈üle≈ümede renkler deƒüi≈ütirildi
- **ƒ∞statistiksel Analiz**: Korelasyon, regresyon ve trend analizleri
- **Performans Metrikleri**: Kazanma oranƒ±, Chess skoru, ROI

---

## üìä Ana Bulgular

### üîç Depth Etkisi
> "Depth arttƒ±k√ßa kazanma oranƒ± nasƒ±l deƒüi≈üiyor?"

**Ana Sonu√ßlar:**
- Depth artƒ±≈üƒ± genellikle performans artƒ±≈üƒ± saƒülƒ±yor
- Ancak diminishing returns (azalan getiri) etkisi g√∂zlemleniyor
- Optimal depth/maliyet dengesi analiz edildi

### ‚öñÔ∏è Lambda Etkisi  
> "Lambda parametresi oyun stilini nasƒ±l etkiliyor?"

**Ana Sonu√ßlar:**
- D√º≈ü√ºk lambda: Konservatif, g√ºvenli oyun
- Y√ºksek lambda: Agresif, risk alan oyun
- Optimal deƒüer pozisyona g√∂re deƒüi≈üiyor

### ‚è±Ô∏è Zaman-Performans Dengesi
> "Hangi depth deƒüeri en iyi ROI saƒülƒ±yor?"

**Ana Sonu√ßlar:**
- Exponential zaman artƒ±≈üƒ± g√∂zlemlendi
- Belirli bir depth'ten sonra ROI azalƒ±yor
- Pratik kullanƒ±m i√ßin optimal aralƒ±k belirlendi

---

## üé≠ Oyun Fazlarƒ± Kar≈üƒ±la≈ütƒ±rmasƒ±

Botun farklƒ± oyun fazlarƒ±ndaki performansƒ±:

- **A√ßƒ±lƒ±≈ü**: Standart prensiplere dayalƒ± oyun
- **Orta Oyun**: Taktiksel karma≈üƒ±klƒ±k artƒ±≈üƒ±
- **Son Oyun**: Teknik doƒüruluk kritik

---

## üí° Pratik √ñneriler

### ‚ö° Hƒ±zlƒ± Oyun ƒ∞√ßin
- **√ñnerilen Depth**: 4-6
- **√ñnerilen Lambda**: 0.5-0.7
- **Beklenen Performans**: Y√ºksek ROI

### üéØ Yarƒ±≈üma ƒ∞√ßin  
- **√ñnerilen Depth**: 8-10
- **√ñnerilen Lambda**: Pozisyona adaptif
- **Beklenen Performans**: Maksimum g√º√ß

### üïí Sƒ±nƒ±rlƒ± Zaman ƒ∞√ßin
- **Zaman B√ºt√ßesi Tabanlƒ±**: Otomatik parametre se√ßimi
- **Adaptif Ayarlar**: Pozisyon tipine g√∂re
- **Performans Garantisi**: ROI optimizasyonu

---

## üìà Teknik Detaylar

### ƒ∞statistiksel Metrikler
- **G√ºven Aralƒ±ƒüƒ±**: %95
- **√ñrneklem B√ºy√ºkl√ºƒü√º**: Konfig√ºrasyon ba≈üƒ±na minimum 20 oyun
- **Anlamlƒ±lƒ±k Testi**: Chi-square, t-test uygulandƒ±

### Grafik ve G√∂rselle≈ütirmeler
- **Heatmap'ler**: Parametre etkile≈üimleri
- **Trend √áizgileri**: Zaman serisi analizleri  
- **ROI Grafikleri**: Maliyet-fayda analizleri
- **Box Plot'lar**: Varyasyon analizleri

---

## üîó Ek Kaynaklar

### √úretilen Dosyalar
- `depth_winrate_analysis.png`: Depth analizi grafikleri
- `time_performance_analysis.png`: Zaman performansƒ±
- `roi_performance_analysis.png`: ROI analizleri
- `game_phases_analysis.png`: Oyun fazlarƒ± kar≈üƒ±la≈ütƒ±rmasƒ±
- `dashboard_data.json`: ƒ∞nteraktif dashboard verisi

### Veri Setleri
- Ham sonu√ßlar CSV formatƒ±nda
- ƒ∞statistiksel analiz R/Python scriptleri
- Reproducible research dosyalarƒ±

---

*Bu rapor otomatik olarak {time.strftime('%Y-%m-%d %H:%M:%S')} tarihinde olu≈üturulmu≈ütur.*
"""

    # Raporu dosyaya kaydet
    with open("comprehensive_report.md", "w", encoding="utf-8") as f:
        f.write(report)

    print("üìÑ Kapsamlƒ± rapor kaydedildi: comprehensive_report.md")

# === Quantum-Inspired Asymptotic Analysis ===

def analyze_asymptotic_convergence(depth_range=None, lambda_range=None, games_per_config=30):
    """
    Depth ve Lambda sonsuza giderken kazanma oranƒ±nƒ±n asimptotik davranƒ±≈üƒ±nƒ± analiz et
    Quantum bilgisayarlar arasƒ± ma√ß senaryosu i√ßin konverjans analizi

    Args:
        depth_range: Test edilecek y√ºksek depth deƒüerleri
        lambda_range: Test edilecek y√ºksek lambda deƒüerleri
        games_per_config: Her konfig√ºrasyon i√ßin oyun sayƒ±sƒ±

    Returns:
        dict: Asimptotik analiz sonu√ßlarƒ±
    """

    if depth_range is None:
        # Quantum-level depths: √ßok y√ºksek deƒüerler
        depth_range = [5, 10, 15, 20, 25, 30, 40, 50, 75, 100]

    if lambda_range is None:
        # Quantum-level lambdas: √ßok y√ºksek deƒüerler
        lambda_range = [0.5, 1.0, 2.0, 5.0, 10.0, 20.0, 50.0, 100.0]

    print("üåå Quantum-Inspired Asimptotik Konverjans Analizi")
    print("=" * 60)
    print("üéØ Ama√ß: Depth‚Üí‚àû ve Lambda‚Üí‚àû durumunda kazanma oranƒ±‚Üí1 konverjansƒ±")
    print(f"üìä Test edilecek depth'ler: {depth_range}")
    print(f"üìä Test edilecek lambda'lar: {lambda_range}")
    print("-" * 60)

    convergence_results = {
        'depth_convergence': {},
        'lambda_convergence': {},
        'combined_convergence': {},
        'asymptotic_analysis': {}
    }

    # 1. Depth Konverjansƒ± (Lambda sabit)
    print("\nüîç 1. DEPTH KONVERJANS ANALƒ∞Zƒ∞ (Lambda=1.0 sabit)")
    print("-" * 40)

    reference_depth = 5  # D√º≈ü√ºk referans
    fixed_lambda = 1.0

    for test_depth in tqdm(depth_range, desc="Depth konverjansƒ±"):
        print(f"\n  üéØ Test Depth: {test_depth}")

        # Test botu ve referans bot
        quantum_bot = ChessBot(depth=test_depth, lambda_val=fixed_lambda, name=f"Quantum_D{test_depth}")
        classical_bot = ChessBot(depth=reference_depth, lambda_val=fixed_lambda, name=f"Classical_D{reference_depth}")

        quantum_bot.reset_stats()
        classical_bot.reset_stats()

        run_tournament(quantum_bot, classical_bot,
                      "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
                      games_per_config)

        total_games = quantum_bot.wins + quantum_bot.losses + quantum_bot.draws
        win_rate = quantum_bot.wins / total_games if total_games > 0 else 0

        convergence_results['depth_convergence'][test_depth] = {
            'win_rate': win_rate,
            'wins': quantum_bot.wins,
            'losses': quantum_bot.losses,
            'draws': quantum_bot.draws,
            'total_games': total_games,
            'dominance_ratio': win_rate / (1 - win_rate) if win_rate < 1 else float('inf')
        }

        print(f"    Kazanma oranƒ±: {win_rate:.4f}")
        print(f"    Sonu√ßlar: {quantum_bot.wins}W-{quantum_bot.losses}L-{quantum_bot.draws}D")

    # 2. Lambda Konverjansƒ± (Depth sabit)
    print("\nüîç 2. LAMBDA KONVERJANS ANALƒ∞Zƒ∞ (Depth=10 sabit)")
    print("-" * 40)

    fixed_depth = 10
    reference_lambda = 0.5

    for test_lambda in tqdm(lambda_range, desc="Lambda konverjansƒ±"):
        print(f"\n  üéØ Test Lambda: {test_lambda}")

        # Test botu ve referans bot
        aggressive_bot = ChessBot(depth=fixed_depth, lambda_val=test_lambda, name=f"Aggressive_L{test_lambda}")
        conservative_bot = ChessBot(depth=fixed_depth, lambda_val=reference_lambda, name=f"Conservative_L{reference_lambda}")

        aggressive_bot.reset_stats()
        conservative_bot.reset_stats()

        run_tournament(aggressive_bot, conservative_bot,
                      "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
                      games_per_config)

        total_games = aggressive_bot.wins + aggressive_bot.losses + aggressive_bot.draws
        win_rate = aggressive_bot.wins / total_games if total_games > 0 else 0

        convergence_results['lambda_convergence'][test_lambda] = {
            'win_rate': win_rate,
            'wins': aggressive_bot.wins,
            'losses': aggressive_bot.losses,
            'draws': aggressive_bot.draws,
            'total_games': total_games,
            'dominance_ratio': win_rate / (1 - win_rate) if win_rate < 1 else float('inf')
        }

        print(f"    Kazanma oranƒ±: {win_rate:.4f}")
        print(f"    Sonu√ßlar: {aggressive_bot.wins}W-{aggressive_bot.losses}L-{aggressive_bot.draws}D")

    # 3. Kombine Konverjans (Her ikisi de y√ºksek)
    print("\nüîç 3. KOMBƒ∞NE KONVERJANS (Depth ve Lambda birlikte y√ºkselir)")
    print("-" * 40)

    quantum_configs = [
        (10, 2.0), (20, 5.0), (30, 10.0), (50, 20.0), (100, 50.0)
    ]

    for depth, lambda_val in tqdm(quantum_configs, desc="Quantum konverjansƒ±"):
        print(f"\n  üåå Quantum Config: D{depth}_L{lambda_val}")

        # Quantum seviye bot vs klasik bot
        quantum_bot = ChessBot(depth=depth, lambda_val=lambda_val, name=f"Quantum_D{depth}L{lambda_val}")
        classical_bot = ChessBot(depth=5, lambda_val=0.5, name="Classical_D5L0.5")

        quantum_bot.reset_stats()
        classical_bot.reset_stats()

        run_tournament(quantum_bot, classical_bot,
                      "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
                      games_per_config)

        total_games = quantum_bot.wins + quantum_bot.losses + quantum_bot.draws
        win_rate = quantum_bot.wins / total_games if total_games > 0 else 0

        config_key = f"D{depth}_L{lambda_val}"
        convergence_results['combined_convergence'][config_key] = {
            'depth': depth,
            'lambda': lambda_val,
            'win_rate': win_rate,
            'wins': quantum_bot.wins,
            'losses': quantum_bot.losses,
            'draws': quantum_bot.draws,
            'total_games': total_games,
            'quantum_advantage': win_rate - 0.5,  # Baseline'dan sapma
            'dominance_ratio': win_rate / (1 - win_rate) if win_rate < 1 else float('inf')
        }

        print(f"    Kazanma oranƒ±: {win_rate:.4f}")
        print(f"    Quantum avantajƒ±: {win_rate - 0.5:.4f}")

    # Asimptotik analiz
    analyze_convergence_patterns(convergence_results)

    # G√∂rselle≈ütir
    plot_quantum_convergence_analysis(convergence_results)

    return convergence_results

def analyze_convergence_patterns(convergence_results):
    """Konverjans desenlerini matematiksel olarak analiz et"""

    print("\nüßÆ ASƒ∞MPTOTƒ∞K KONVERJANS ANALƒ∞Zƒ∞")
    print("=" * 50)

    # Depth konverjansƒ± analizi
    depths = sorted(convergence_results['depth_convergence'].keys())
    depth_win_rates = [convergence_results['depth_convergence'][d]['win_rate'] for d in depths]

    # Lambda konverjansƒ± analizi
    lambdas = sorted(convergence_results['lambda_convergence'].keys())
    lambda_win_rates = [convergence_results['lambda_convergence'][l]['win_rate'] for l in lambdas]

    print("\nüìà DEPTH KONVERJANS TRENDƒ∞:")
    print("-" * 30)

    # Depth trend analizi
    if len(depths) >= 3:
        # Exponential fit: y = a * (1 - b * exp(-c * x))
        try:
            from scipy.optimize import curve_fit

            def asymptotic_func(x, a, b, c):
                return a * (1 - b * np.exp(-c * x))

            # Fit depth data
            popt_depth, _ = curve_fit(asymptotic_func, depths, depth_win_rates,
                                    bounds=([0.5, 0, 0], [1.0, 2, 1]))

            asymptotic_limit_depth = popt_depth[0]
            convergence_rate_depth = popt_depth[2]

            print(f"  üéØ Asimptotik limit (Depth‚Üí‚àû): {asymptotic_limit_depth:.6f}")
            print(f"  üìä Konverjans hƒ±zƒ±: {convergence_rate_depth:.6f}")

            # 1'e konverjans kontrol√º
            if asymptotic_limit_depth > 0.95:
                print("  ‚úÖ Depth‚Üí‚àû durumunda kazanma oranƒ± 1'e yakƒ±nsƒ±yor!")
            elif asymptotic_limit_depth > 0.8:
                print(f"  ‚ö†Ô∏è  Depth‚Üí‚àû durumunda kazanma oranƒ± {asymptotic_limit_depth:.3f}'e yakƒ±nsƒ±yor")
            else:
                print(f"  ‚ùå Depth‚Üí‚àû durumunda kazanma oranƒ± sadece {asymptotic_limit_depth:.3f}'e yakƒ±nsƒ±yor")

        except:
            print("  ‚ö†Ô∏è  Asimptotik fit hesaplanamadƒ±")

    print("\nüìà LAMBDA KONVERJANS TRENDƒ∞:")
    print("-" * 30)

    # Lambda trend analizi
    if len(lambdas) >= 3:
        try:
            # Log-linear fit for lambda
            log_lambdas = np.log(lambdas)
            coeffs = np.polyfit(log_lambdas, lambda_win_rates, 1)

            # Extrapolate to very high lambda
            predicted_at_high_lambda = coeffs[0] * np.log(1000) + coeffs[1]

            print(f"  üéØ Lambda=1000 tahmini kazanma oranƒ±: {predicted_at_high_lambda:.6f}")
            print(f"  üìä Lambda artƒ±≈ü eƒüimi: {coeffs[0]:.6f}")

            if predicted_at_high_lambda > 0.95:
                print("  ‚úÖ Lambda‚Üí‚àû durumunda kazanma oranƒ± 1'e yakƒ±nsƒ±yor!")
            elif predicted_at_high_lambda > 0.8:
                print(f"  ‚ö†Ô∏è  Lambda‚Üí‚àû durumunda kazanma oranƒ± {predicted_at_high_lambda:.3f}'e yakƒ±nsƒ±yor")
            else:
                print(f"  ‚ùå Lambda‚Üí‚àû durumunda kazanma oranƒ± sadece {predicted_at_high_lambda:.3f}'e yakƒ±nsƒ±yor")

        except:
            print("  ‚ö†Ô∏è  Lambda trend analizi hesaplanamadƒ±")

    # Quantum supremacy analizi
    print("\nüåå QUANTUM SUPREMACY ANALƒ∞Zƒ∞:")
    print("-" * 30)

    combined_results = convergence_results['combined_convergence']
    if combined_results:
        max_win_rate = max(result['win_rate'] for result in combined_results.values())
        max_config = max(combined_results.items(), key=lambda x: x[1]['win_rate'])

        print(f"  üèÜ En y√ºksek kazanma oranƒ±: {max_win_rate:.6f}")
        print(f"  üéØ En iyi konfig√ºrasyon: {max_config[0]}")
        print(f"  üöÄ Quantum avantajƒ±: {max_win_rate - 0.5:.6f}")

        if max_win_rate > 0.99:
            print("  ‚úÖ QUANTUM SUPREMACY ACHIEVED! Neredeyse m√ºkemmel performans!")
        elif max_win_rate > 0.9:
            print("  üéØ G√º√ßl√º quantum avantajƒ± g√∂zlemlendi")
        elif max_win_rate > 0.7:
            print("  üìà Orta seviye quantum avantajƒ±")
        else:
            print("  ‚ö†Ô∏è  Sƒ±nƒ±rlƒ± quantum avantajƒ±")

def plot_quantum_convergence_analysis(convergence_results):
    """Quantum konverjans analizini g√∂rselle≈ütir"""

    fig = plt.figure(figsize=(20, 15))

    # 1. Depth Konverjansƒ±
    ax1 = plt.subplot(2, 3, 1)
    depths = sorted(convergence_results['depth_convergence'].keys())
    depth_win_rates = [convergence_results['depth_convergence'][d]['win_rate'] for d in depths]

    ax1.plot(depths, depth_win_rates, 'bo-', linewidth=3, markersize=8, label='Ger√ßek Veri')
    ax1.axhline(y=1.0, color='red', linestyle='--', alpha=0.7, label='Teorik Limit (1.0)')
    ax1.axhline(y=0.5, color='gray', linestyle=':', alpha=0.5, label='Rastgele (0.5)')

    # Asimptotik fit √ßizgisi
    if len(depths) >= 3:
        x_extended = np.linspace(min(depths), max(depths)*2, 100)
        try:
            from scipy.optimize import curve_fit
            def asymptotic_func(x, a, b, c):
                return a * (1 - b * np.exp(-c * x))
            popt, _ = curve_fit(asymptotic_func, depths, depth_win_rates,
                              bounds=([0.5, 0, 0], [1.0, 2, 1]))
            y_fit = asymptotic_func(x_extended, *popt)
            ax1.plot(x_extended, y_fit, 'r--', alpha=0.8, label=f'Asimptotik Fit (limit={popt[0]:.3f})')
        except:
            pass

    ax1.set_xlabel('Depth')
    ax1.set_ylabel('Kazanma Oranƒ±')
    ax1.set_title('Depth ‚Üí ‚àû Konverjansƒ±')
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    ax1.set_ylim(0, 1.1)

    # 2. Lambda Konverjansƒ±
    ax2 = plt.subplot(2, 3, 2)
    lambdas = sorted(convergence_results['lambda_convergence'].keys())
    lambda_win_rates = [convergence_results['lambda_convergence'][l]['win_rate'] for l in lambdas]

    ax2.semilogx(lambdas, lambda_win_rates, 'go-', linewidth=3, markersize=8, label='Ger√ßek Veri')
    ax2.axhline(y=1.0, color='red', linestyle='--', alpha=0.7, label='Teorik Limit (1.0)')
    ax2.axhline(y=0.5, color='gray', linestyle=':', alpha=0.5, label='Rastgele (0.5)')

    ax2.set_xlabel('Lambda (log scale)')
    ax2.set_ylabel('Kazanma Oranƒ±')
    ax2.set_title('Lambda ‚Üí ‚àû Konverjansƒ±')
    ax2.legend()
    ax2.grid(True, alpha=0.3)
    ax2.set_ylim(0, 1.1)

    # 3. Quantum Supremacy Map
    ax3 = plt.subplot(2, 3, 3)
    combined_results = convergence_results['combined_convergence']

    if combined_results:
        configs = list(combined_results.keys())
        depths_combined = [combined_results[c]['depth'] for c in configs]
        lambdas_combined = [combined_results[c]['lambda'] for c in configs]
        win_rates_combined = [combined_results[c]['win_rate'] for c in configs]

        scatter = ax3.scatter(depths_combined, lambdas_combined, c=win_rates_combined,
                            s=200, cmap='RdYlGn', vmin=0.5, vmax=1.0, alpha=0.8)

        # Annotations
        for i, config in enumerate(configs):
            ax3.annotate(f'{win_rates_combined[i]:.2f}',
                        (depths_combined[i], lambdas_combined[i]),
                        xytext=(5, 5), textcoords='offset points', fontweight='bold')

        plt.colorbar(scatter, ax=ax3, label='Kazanma Oranƒ±')
        ax3.set_xlabel('Depth')
        ax3.set_ylabel('Lambda')
        ax3.set_title('Quantum Supremacy Map')
        ax3.set_yscale('log')

    # 4. Dominance Ratio (Win rate / Loss rate)
    ax4 = plt.subplot(2, 3, 4)
    dominance_ratios_depth = []
    for d in depths:
        win_rate = convergence_results['depth_convergence'][d]['win_rate']
        if win_rate < 1.0:
            dominance_ratios_depth.append(win_rate / (1 - win_rate))
        else:
            dominance_ratios_depth.append(100)  # Cap for visualization

    ax4.semilogy(depths, dominance_ratios_depth, 'mo-', linewidth=3, markersize=8)
    ax4.set_xlabel('Depth')
    ax4.set_ylabel('Dominance Ratio (log scale)')
    ax4.set_title('Depth ‚Üí ‚àû Dominance Explosion')
    ax4.grid(True, alpha=0.3)

    # 5. Lambda Dominance
    ax5 = plt.subplot(2, 3, 5)
    dominance_ratios_lambda = []
    for l in lambdas:
        win_rate = convergence_results['lambda_convergence'][l]['win_rate']
        if win_rate < 1.0:
            dominance_ratios_lambda.append(win_rate / (1 - win_rate))
        else:
            dominance_ratios_lambda.append(100)

    ax5.loglog(lambdas, dominance_ratios_lambda, 'co-', linewidth=3, markersize=8)
    ax5.set_xlabel('Lambda (log scale)')
    ax5.set_ylabel('Dominance Ratio (log scale)')
    ax5.set_title('Lambda ‚Üí ‚àû Dominance Explosion')
    ax5.grid(True, alpha=0.3)

    # 6. Convergence Comparison
    ax6 = plt.subplot(2, 3, 6)

    # Normalize for comparison
    normalized_depths = np.array(depths) / max(depths)
    normalized_lambdas = np.array(lambdas) / max(lambdas)

    ax6.plot(normalized_depths, depth_win_rates, 'b-', linewidth=3, label='Depth Konverjansƒ±', marker='o')
    ax6.plot(normalized_lambdas, lambda_win_rates, 'g-', linewidth=3, label='Lambda Konverjansƒ±', marker='s')
    ax6.axhline(y=1.0, color='red', linestyle='--', alpha=0.7, label='Teorik Limit')

    ax6.set_xlabel('Normalized Parameter (0-1)')
    ax6.set_ylabel('Kazanma Oranƒ±')
    ax6.set_title('Konverjans Kar≈üƒ±la≈ütƒ±rmasƒ±')
    ax6.legend()
    ax6.grid(True, alpha=0.3)
    ax6.set_ylim(0, 1.1)

    plt.tight_layout()
    plt.savefig("quantum_convergence_analysis.png", dpi=300, bbox_inches='tight')
    plt.close()

    print("üåå Quantum konverjans analizi kaydedildi: quantum_convergence_analysis.png")
